name: CI Tests

on:
  pull_request:
    branches: [main, dev]
  push:
    branches: [main]

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Fast feedback jobs that run in parallel
  lint:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run TypeScript check
        run: npx tsc --noEmit

      - name: Run ESLint
        run: npm run lint

  # Unit tests split into parallel shards
  unit-tests:
    name: Unit Tests (Shard ${{ matrix.shard }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        shard: [1, 2, 3, 4]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests (shard ${{ matrix.shard }})
        run: |
          set -o pipefail
          npm run test -- --ci --watchAll=false --shard=${{ matrix.shard }}/4 --maxWorkers=4 --coverage=false 2>&1 | tee test-output-${{ matrix.shard }}.log

      - name: Upload test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-logs-shard-${{ matrix.shard }}
          path: test-output-${{ matrix.shard }}.log

  # Component/Integration tests
  component-tests:
    name: Component Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run component tests
        run: |
          set -o pipefail
          npm run test -- --ci --watchAll=false --testPathPatterns="components|hooks" --maxWorkers=4 --coverage=false 2>&1 | tee component-test-output.log

      - name: Upload component test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: component-test-logs
          path: component-test-output.log

  # API tests
  api-tests:
    name: API Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run API tests
        run: |
          set -o pipefail
          npm run test -- --ci --watchAll=false --testPathPatterns="api" --maxWorkers=4 --coverage=false 2>&1 | tee api-test-output.log

      - name: Upload API test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: api-test-logs
          path: api-test-output.log

  # Build job (runs in parallel with tests)
  build:
    name: Build Application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: .next/

  # Coverage collection (depends on all test jobs)
  coverage:
    name: Collect Coverage
    runs-on: ubuntu-latest
    needs: [unit-tests, component-tests, api-tests]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download all test artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: "*test-logs*"
          merge-multiple: true

      - name: Generate combined coverage report
        run: |
          # Run tests again to generate coverage (this is fast since we're not running all tests)
          npm run test:coverage -- --passWithNoTests

      - name: Upload coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/

  # Integration tests (runs after unit tests pass)
  integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [lint, unit-tests, build]
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Setup Docker Compose
        run: |
          # Verify docker compose is available
          if ! command -v docker &> /dev/null; then
            echo "Docker is not available on this runner"
            exit 1
          fi

          # Check if docker compose command exists (newer versions use 'docker compose')
          if docker compose version &> /dev/null; then
            echo "Using 'docker compose'"
          elif docker-compose --version &> /dev/null; then
            echo "Using 'docker-compose'"
            # Create alias for consistency
            echo 'alias docker-compose="docker compose"' >> ~/.bashrc
          else
            echo "Neither 'docker compose' nor 'docker-compose' is available"
            exit 1
          fi

      - name: Start services with Docker
        run: docker compose up -d

      - name: Wait for services
        run: sleep 30

      - name: Run integration tests
        run: |
          set -o pipefail
          # Check if integration test config exists, if not, skip gracefully
          if [ ! -f "jest.integration.config.js" ]; then
            echo "Integration test configuration not found. Creating basic config..."
            cat > jest.integration.config.js << 'EOF'
          const nextJest = require('next/jest')

          const createJestConfig = nextJest({
            dir: './',
          })

          const customJestConfig = {
            setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
            moduleNameMapping: {
              '^@/components/(.*)$': '<rootDir>/components/$1',
              '^@/pages/(.*)$': '<rootDir>/pages/$1',
              '^@/lib/(.*)$': '<rootDir>/lib/$1',
              '^@/hooks/(.*)$': '<rootDir>/hooks/$1',
            },
            testEnvironment: 'jest-environment-jsdom',
            testMatch: ['**/__tests__/**/*integration*.test.{js,jsx,ts,tsx}'],
            collectCoverageFrom: [
              '**/*.{js,jsx,ts,tsx}',
              '!**/*.d.ts',
              '!**/node_modules/**',
            ],
          }

          module.exports = createJestConfig(customJestConfig)
          EOF
          fi

          # Run integration tests and capture output
          npm run test:integration 2>&1 | tee integration-output.log

          # Check if tests actually ran and passed
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "Integration tests failed!"
            exit 1
          fi

          # Check if any tests were found and executed
          if grep -q "No tests found" integration-output.log; then
            echo "No integration tests found. This is expected if integration tests haven't been implemented yet."
            echo "Integration test setup completed successfully." >> integration-output.log
          fi

      - name: Stop services
        if: always()
        run: docker compose down

      - name: Upload integration logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-logs
          path: integration-output.log

  # Status check job (required for branch protection)
  ci-status:
    name: CI Status Check
    runs-on: ubuntu-latest
    needs: [lint, unit-tests, component-tests, api-tests, build, integration]
    if: always()
    steps:
      - name: Check all jobs status
        run: |
          if [[ "${{ needs.lint.result }}" == "success" && 
                "${{ needs.unit-tests.result }}" == "success" && 
                "${{ needs.component-tests.result }}" == "success" && 
                "${{ needs.api-tests.result }}" == "success" && 
                "${{ needs.build.result }}" == "success" && 
                "${{ needs.integration.result }}" == "success" ]]; then
            echo "All CI checks passed!"
            exit 0
          else
            echo "Some CI checks failed!"
            exit 1
          fi

      - name: Post failure summary on PR
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const jobs = {
              lint: "${{ needs.lint.result }}",
              "unit-tests": "${{ needs.unit-tests.result }}",
              "component-tests": "${{ needs.component-tests.result }}",
              "api-tests": "${{ needs.api-tests.result }}",
              build: "${{ needs.build.result }}",
              integration: "${{ needs.integration.result }}"
            };

            const failed = Object.entries(jobs)
              .filter(([_, status]) => status === 'failure')
              .map(([job, _]) => job);

            const issue_number = context.payload.pull_request.number;
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number,
              body: `ðŸš¨ **CI Pipeline Failed**\n\n**Failed Jobs:** ${failed.join(', ')}\n\nCheck the [workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`
            });
